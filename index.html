<!DOCTYPE html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <title>John Li</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
  <link rel="stylesheet" type="text/css" href="main.css" />
  <script src="abstracts.js"></script>
  <script>
    window.onload = () => {
      let p = Math.random();
      let theta = -60 + Math.floor(Math.random() * 120);
      console.log(p, theta);
      if (p < 0.00001) {
        let css = `
          @-webkit-keyframes fadein {
              0% { display: none; opacity: 0; }
              1% { display: block; opacity: 0; }
              100% { display: block; opacity: 1; }
          }
          @-moz-keyframes fadein {
              0% { display: none; opacity: 0; }
              1% { display: block; opacity: 0; }
              100% { display: block; opacity: 1; }
          }
          @-o-keyframes fadein {
              0% { display: none; opacity: 0; }
              1% { display: block; opacity: 0; }
              100% { display: block; opacity: 1; }
          }
          @keyframes fadein {
              0% { display: none; opacity: 0; }
              1% { display: block; opacity: 0; }
              100% { display: block; opacity: 1; }
          }
          @-webkit-keyframes fadeout {
              0% { display: block; opacity: 1; }
              99% { display: block; opacity: 0; }
              100% { display: none; opacity: 0; }
          }
          @-moz-keyframes fadeout {
              0% { display: block; opacity: 1; }
              99% { display: block; opacity: 0; }
              100% { display: none; opacity: 0; }
          }
          @-o-keyframes fadeout {
              0% { display: block; opacity: 1; }
              99% { display: block; opacity: 0; }
              100% { display: none; opacity: 0; }
          }
          @keyframes fadeout {
              0% { display: block; opacity: 1; }
              99% { display: block; opacity: 0; }
              100% { display: none; opacity: 0; }
          }
        `;
        let fadein = `
          display: block;
          -webkit-animation: fadein 5s ease-out;
          -moz-animation: fadein 5s ease-out;
          -o-animation: fadein 5s ease-out;
          animation: fadein 5s ease-out;
        `;
        let fadeout = `
          display: block;
          -webkit-animation: fadeout 5s ease-out;
          -moz-animation: fadeout 5s ease-out;
          -o-animation: fadeout 5s ease-out;
          animation: fadeout 5s ease-out;
        `;
        let picdimensions = `
          width: 75%;
          height: 75%;
          rotate: ${theta}deg;
          top: 12%;
          position: absolute;
        `;
        document.body.innerHTML = `
          <style>${css}</style>
          <img src="http://olekg.pl/assets/angery.png" style="z-index: 1; ${picdimensions}; ${fadein}"></img>
          <img src="http://olekg.pl/assets/headshot.png" style="z-index: 0; ${picdimensions}; ${fadeout}"></img>
        `;
      }
    };
  </script>
</head>
<body>

<br>
<img src="photo.jpg" style="width: 10em; margin-left: 1em; float: right">
<h1 class="title">John Li <span style="font-size:50%"><a href="cv.pdf">CV</a></span></h1>
<p>
I'm a PhD student in programming languages working with
<a href="http://www.ccs.neu.edu/home/amal/">Amal Ahmed</a>
and
<a href="https://www.khoury.northeastern.edu/home/sholtzen/">Steven Holtzen</a>
at Northeastern University.
I'm generally interested in logic, semantics, and mechanized proof;
lately I've been thinking about connections between mutable state and probability theory.
Before starting my PhD, I built a verified-optimization-pass generator as
part of the <a href="https://certicoq.org/">CertiCoq</a> project.
When I'm not thinking about research, I like learning math,
playing bullet chess, violin, and <a href="https://sympa.inria.fr/sympa/arc/coq-club/2020-01/msg00095.html">ping pong</a>.
</p>

<small>
<table><tr><td><img src="http://math.jhu.edu/~savitt/GTM/massey.jpg" width=120 height=187 alt=""></td><td><p>If I were a Springer-Verlag Graduate Text in Mathematics, I would be William S. Massey's <b><i>A Basic Course in Algebraic Topology</i></b>.</p><p> I am intended to serve as a textbook for a course in algebraic topology at the beginning graduate level. The main topics covered are the classification of compact 2-manifolds, the fundamental group, covering spaces, singular homology theory, and singular cohomology theory. These topics are developed systematically, avoiding all unecessary definitions, terminology, and technical machinery. Wherever possible, the geometric motivation behind the various concepts is emphasized. </p><p>Which Springer GTM would <i>you</i> be?  <a href="http://math.jhu.edu/~savitt/GTM.html">The Springer GTM Test</a></p></td></tr></table>
</small>

<br/>

<h3>Papers</h3>

<table class="entries">
  <tr>
    <td>
      Lilac: A Modal Separation Logic for Conditional Probability
      <span class="label">PLDI 2023</span>
      <br/><small>John M. Li, Amal Ahmed, and Steven Holtzen.</small>
      <br/>
        <small><a href="#" onclick="toggleAbstract('lilac'); return false;">Abstract</a></small>
        &nbsp;&nbsp;
        <small><a href="https://arxiv.org/abs/2304.01339">arXiv</a></small>
        &nbsp;&nbsp;
        <small><a href=lilac-a-modal-separation-logic-for-conditional-probability.pdf>Local copy</a></small>
      <br/><span id="lilac-abstract" class="abstract">
        We present Lilac, a separation logic for reasoning about probabilistic
        programs where separating conjunction captures probabilistic
        independence. Inspired by an analogy with mutable state where sampling
        corresponds to dynamic allocation, we show how probability spaces over a
        fixed, ambient sample space appear to be the natural analogue of heap
        fragments, and present a new combining operation on them such that
        probability spaces behave like heaps and measurability of random
        variables behaves like ownership. This combining operation forms the
        basis for our model of separation, and produces a logic with many
        pleasant properties. In particular, Lilac has a frame rule identical to
        the ordinary one, and naturally accommodates advanced features like
        continuous random variables and reasoning about quantitative properties
        of programs. Then we propose a new modality based on disintegration
        theory for reasoning about conditional probability. We show how the
        resulting modal logic validates examples from prior work, and give a
        formal verification of an intricate weighted sampling algorithm whose
        correctness depends crucially on conditional independence structure.
      </span>
    </td>
  </tr>
  <tr>
    <td>
      Deriving Efficient Program Transformations from Rewrite Rules
      <span class="label">ICFP 2021</span>
      <br/><small>John M. Li and Andrew W. Appel.</small>
      <br/>
        <small><a href="#" onclick="toggleAbstract('deriver'); return false;">Abstract</a></small>
        &nbsp;&nbsp;
        <small><a href=deriving-efficient-program-transformations-from-rewrite-rules-slides.pdf>Slides</a></small>
        &nbsp;&nbsp;
        <small><a href=https://dl.acm.org/doi/10.1145/3473579>DOI</a></small>
        &nbsp;&nbsp;
        <small><a href=deriving-efficient-program-transformations-from-rewrite-rules.pdf>Local copy</a></small>
      <br/><span id="deriver-abstract" class="abstract">
        An efficient optimizing compiler can perform many cascading rewrites in
        a single pass, using auxiliary data structures such as variable binding
        maps, delayed substitutions, and occurrence counts. Such optimizers
        often perform transformations according to relatively simple rewrite
        rules, but the subtle interactions between the data structures needed
        for efficiency make them tricky to write and trickier to prove correct.
        We present a system for semi-automatically deriving both an efficient
        program transformation and its correctness proof from a list of rewrite
        rules and specifications of the auxiliary data structures it requires.
        Dependent types ensure that the holes left behind by our system (for the
        user to fill in) are filled in correctly, allowing the user low-level
        control over the implementation without having to worry about getting it
        wrong. We implemented our system in Coq (though it could be implemented
        in other logics as well), and used it to write optimization passes that
        perform uncurrying, inlining, dead code elimination, and static
        evaluation of case expressions and record projections. The generated
        implementations are sometimes faster, and at most 40% slower, than
        hand-written counterparts on a small set of benchmarks; in some cases,
        they require significantly less code to write and prove correct.
      </span>
    </td>
  </tr>
  <tr>
    <td>
      Compositional Optimizations for CertiCoq
      <span style="float: right">ICFP 2021</span>
      <br/><small>Zoe Paraskevopoulou, John M. Li, and Andrew W. Appel.</small>
      <br/>
        <small><a href="#" onclick="toggleAbstract('certicoq'); return false;">Abstract</a></small>
        &nbsp;&nbsp;
        <small><a href=https://dl.acm.org/doi/10.1145/3473591>DOI</a></small>
        &nbsp;&nbsp;
        <small><a href=compositional-optimizations-for-certicoq.pdf>Local copy</a></small>
      <br/><span id="certicoq-abstract" class="abstract">
        Compositional compiler verification is a difficult problem that focuses
        on separate compilation of program components with possibly different
        verified compilers. Logical relations are widely used in proving
        correctness of program transformations in higher-order languages;
        however, they do not scale to compositional verification of multi-pass
        compilers due to their lack of transitivity. The only known technique to
        apply to compositional verification of multi-pass compilers for
        higher-order languages is parametric inter-language simulations (PILS),
        which is however significantly more complicated than traditional proof
        techniques for compiler correctness.  In this paper, we present a novel
        verification framework for <i>lightweight compositional compiler
        correctness</i>. We demonstrate that by imposing the additional restriction
        that program components are compiled by pipelines that go through <i>the
        same sequence of intermediate representations</i>, logical relation proofs
        can be transitively composed in order to derive an end-to-end
        compositional specification for multi-pass compiler pipelines.  Unlike
        traditional logical-relation frameworks, our framework supports
        divergence preservation---even when transformations reduce the number of
        program steps. We achieve this by parameterizing our logical relations
        with a pair of <i>relational invariants</i>.
        <br/>
        <br/>
        We apply this technique to verify a multi-pass, optimizing middle-end
        pipeline for CertiCoq, a compiler from Gallina (Coq's specification
        language) to C. The pipeline optimizes and closure-converts an untyped
        functional intermediate language (ANF or CPS) to a subset of that
        language without nested functions, which can be easily code-generated to
        low-level languages. Notably, our pipeline performs more complex
        closure-allocation optimizations than the state of the art in verified
        compilation. Using our novel verification framework, we prove an
        end-to-end theorem for our pipeline that covers both termination and
        divergence and applies to whole-program and separate compilation, even
        when different modules are compiled with different optimizations.  Our
        results are mechanized in the Coq proof assistant.
      </span>
    </td>
  </tr>
</table>

<h3>Talks</h3>

<table class="entries">
  <tr>
    <td>
      New Foundations for Probabilistic Separation Logic<span class="label">LAFI @ POPL 2023</span>
      <br/><small>John M. Li, Amal Ahmed, and Steven Holtzen.</small>
      <br/>
        <small><a href="lafi-extended-abstract.pdf">Extended Abstract</a></small>
        &nbsp;&nbsp;
        <small><a href=new-foundations-for-probabilistic-separation-logic.pdf>Slides</a></small>
        &nbsp;&nbsp;
        <small><a href="new-foundations-for-probabilistic-separation-logic-poster.pdf">Poster</a></small>
    </td>
  </tr>
</table>

<br/>
<br/>
<br/>
<br/>
<br/>
<a href='https://cho.minsung.pl/' style='font-size:1px'>m</a>
<a href='https://olekg.pl/' style='font-size:1px'>o</a>

</body>

</html>

